/* -*- Mode: C++; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */

/*! 
 *  \file plq.hpp
 *  \brief Pane-level Query Stage
 *  
 *  Implementation of the Pane-level Query (PLQ) stage, which consists in the
 *  first stage used by the Pane Farming pattern. PLQ is a farm in which the
 *  emitter is responsible to schedule tuples to the PLQ workers, analyze the stream
 *  and generate punctuations to deal with out-of-order tuples. PLQ workers execute
 *  the working logic on the panes, where a tuple belongs to exactly one pane.
 *  The results set of the panes, eventually produced out-of-order, are transmitted
 *  to the next stage of Pane Farming (WLQ).
 *  
 */

/* ***************************************************************************
 *  
 *  This program is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *  
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 *  License for more details.
 *  
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software Foundation,
 *  Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 *  
 ****************************************************************************
 */

/* 
 * Author: Gabriele Mencagli <mencagli@di.unipi.it>
 * April 2016
 */

#ifndef PLQ_H
#define PLQ_H

// include
#include <math.h>
#include <deque>
#include <ff/lb.hpp>
#include <ff/node.hpp>
#include <ff/farm.hpp>
#include <ff/mapping_utils.hpp>
#include <kslack.hpp>
#include <tuple_t.hpp>
#include <general.hpp>
#include <queries.hpp>
#include <sched_plq.hpp>
#include <socket_utils.hpp>

using namespace ff;
using namespace std;

/* 
 * This file provides the following classes:
 * -PLQ_Emitter: class that implements the emitter of the PLQ stage (OOP version);
 * -PLQ_Emitter_IOP: class that implements a IOP version of the PLQ emitter;
 * -PLQ_Worker: class that implements the worker of the PLQ stage (OOP version);
 * -PLQ_Worker_IOP: class that implements a IOP version of the worker of the PLQ stage.
 */

/*! 
 *  \class PLQ_Emitter
 *  
 *  \brief Emitter of the Pane-level Query Stage
 *  
 *  Emitter functionality of the PLQ stage of the Pane Farming. It is
 *  responsible to receive the tuples from the Generator, distributes them
 *  to the PLQ workers, and then evaluate the degree of disordering and
 *  produce punctuations to the PLQ workers to go on on their computations.
 *  
 *  This class is defined in \ref Pane_Farming/include/plq.hpp
 */
class PLQ_Emitter: public ff_node_t<tuple_t> {
private:
	int s; // input socket from the Generator
	size_t pane_length; // temporal length of a pane (in ms)
	size_t nw_plq; // number of PLQ worker instances
	int port; // port to receive the connection from the Generator
	bool pidEnabled; // true if adaptive slack mechanism is enabled
	KSlack_Punc kslack; // standard slack punctuation mechanism
	KSlackPID_Punc kslackpid; // adaptive slack punctuation mechanism
    unsigned long rcv_sample = 0; // number of tuples received in the last sample
    unsigned long dropped_sample = 0; // number of tuples dropped in the last sample
    unsigned long dropped_total = 0; // total number of dropped tuples
    unsigned long rcv_total = 0; // total number of received tuples
    double last_P = 0; // value of the highest punctuation seen so far
	ff_loadbalancer * const lb; // load balancer object for the scheduling to PLQ workers
	ff_buffernode * const ch_controller; // fastflow channel from the elastic controller
	size_t n_punc = 0; // number of punctuations generated by the PLQ emitter
	volatile ticks last_punct_time = 0; // time in ticks of the last punctuation
	bool plqTerminated = false; // if this flag is true the PLQ stage is terminated (or under temination)
#if defined(PB_RR_SCHED)
	PB_RR_Sched *sched;
#elif defined(TB_RR_SCHED)
	TB_RR_Sched *sched;
#elif defined(ADAPTIVE_SCHED)
	Adaptive_Sched *sched;
#elif defined(ADAPTIVE_SCHED_PID)
	Adaptive_Sched_PID *sched;
#endif

	// method to process an input tuple received from the generator
	inline void processNewTuple(tuple_t *t) {
		rcv_sample++;
		rcv_total++;
		// ###################################### START PUNCTUATION MECHANISM ####################################### //
		// case of the standard slack algorithm for punctuation generation
		if(!pidEnabled) {
			double new_punctuation;
			if(kslack.checkStreamProgress(*t, new_punctuation)) {
				// if the time elapsed from the last punctuation is not too short
				if(FROM_TICKS_TO_USECS(getticks()-last_punct_time) >= MAX_TIME_BETWEEN_PUNC_USEC) {
					last_punct_time = getticks();
					n_punc++;
					// compute the pane id corresponding to the new punctuation value
					size_t pane_id = (size_t) (new_punctuation / (pane_length * 1000));
					// generate punctuation (all the panes with id < pane_id are likely complete)
					sched->executeStreamProgress(new_punctuation, pane_id);
				}
				if(new_punctuation > last_P) last_P = new_punctuation;
			}
		}
		// case of the adaptive slack algorithm for punctuation generation
		else {
			double drop_prob =  ((double) dropped_sample)/ ((double) rcv_sample);
			// adapt the slack mechanism
			if(kslackpid.adapt(drop_prob)) {
				// the sampling interval of the PID is finished, we reset the counters for the next one
				dropped_sample = rcv_sample = 0;
			}
			double new_punctuation;
			if(kslackpid.checkStreamProgress(*t, new_punctuation)) {
				// if the time elapsed from the last punctuation is not too short
				if(FROM_TICKS_TO_USECS(getticks()-last_punct_time) >= MAX_TIME_BETWEEN_PUNC_USEC) {
					last_punct_time = getticks();
					n_punc++;
					// compute the pane id corresponding to the new punctuation value
					size_t pane_id = (size_t) (new_punctuation / (pane_length * 1000));
					// generate punctuation (all the panes with id < pane_id are likely complete)
					sched->executeStreamProgress(new_punctuation, pane_id);
				}
				if(new_punctuation > last_P) last_P = new_punctuation;
			}
		}
		// ####################################### END PUNCTUATION MECHANISM ######################################## //
		// if the tuple must be dropped
		if(t->app_ts < last_P) {
			dropped_sample++;
			dropped_total++;
			delete t;
		}
		// if the tuple must be scheduled
		else {
			// ########################################## START SCHEDULING ########################################## //
			sched->sched_to_worker(t);
			// ########################################### END SCHEDULING ########################################### //
		}
	}

public:
	// constructor
	PLQ_Emitter(size_t _len, size_t _nw_plq, size_t _port, double _target_drop_prob, ff_loadbalancer * const _lb, ff_buffernode * const _ch_controller)
	            :pane_length(_len), nw_plq(_nw_plq), port(_port), pidEnabled(_target_drop_prob>0), kslackpid(_target_drop_prob), lb(_lb), ch_controller(_ch_controller) {}

	// destructor
	~PLQ_Emitter() {
	    delete sched;
	}

	// svc_init method
	int svc_init() {
		// set the thread mapping onto a SMT context
		ff_mapThreadToCpu(PLQ_EMITTER_CORE_ID);
		// de-activate all the initially non-utilized PLQ workers
		for(int i=nw_plq; i<NUM_WORKER_THREADS; i++) {
			lb->ff_send_out_to(GO_OUT, i);
		}
		// start connection with the Generator
		int *socket = socket_accept(1, port);
		s = *socket;
		// set the socket in the non-blocking mode
		socket_setblocking(s, false);
		MY_PRINT("Connection from Generator: OK\n");
		// entering the sampling barrier
		pthread_barrier_wait(&sampleBarr);
		volatile ticks starting_time = getticks();
		// scheduling strategy instantiation: it must be exectued here and not in the constructor
#if defined(PB_RR_SCHED)
		sched = new PB_RR_Sched(nw_plq, lb);
#elif defined(TB_RR_SCHED)
		sched = new TB_RR_Sched(nw_plq, lb);
#elif defined(ADAPTIVE_SCHED)
		sched = new Adaptive_Sched(nw_plq, lb);
#elif defined(ADAPTIVE_SCHED_PID)
		sched = new Adaptive_Sched_PID(nw_plq, lb, starting_time, desired_rho); // desired_rho is a global variable
#endif
		return 0;
	}

	// svc_end method
	void svc_end() {
		// close connection with the Generator
		socket_close(s);
		// entering the printing barrier
		pthread_barrier_wait(&printBarr);
		MY_PRINT("********************************PLQ statistics********************************\n" <<\
			      "Dropped: " << dropped_total << "/" << rcv_total << " tuples\n" <<\
			      "Average splitting factor: " << sched->getPLQSplitFactor() << "\n" <<\
			      "No. of punctuations transmitted: " << n_punc << "\n" <<\
			      "******************************************************************************\n");
#if defined(PLQ_ONLY)
		// entering the precedence barrier 1
		pthread_barrier_wait(&precBarr1);
		// entering the precedence barrier 2
		pthread_barrier_wait(&precBarr2);
#else
		// entering the precedence barrier 1
		pthread_barrier_wait(&precBarr1);
		// entering the precedence barrier 2
		pthread_barrier_wait(&precBarr2);
		// entering the precedence barrier 3
		pthread_barrier_wait(&precBarr3);
#endif
	}

	// svc method
	tuple_t *svc(tuple_t *t) {
		char tuple_buffer[tuple_t::getSize()];
		bool stream_complete = false;
		// loop until the end of the stream
		do {
			int received = socket_receive(s, tuple_buffer, tuple_t::getSize());
			if(received == 0) stream_complete = true;
			else if(received == -1) {
				// check the presence of a message from the manager
				Reconf_t *reconf_msg = nullptr;
				ch_controller->gather_task(reconf_msg, 1);
				if(reconf_msg != nullptr) {
					// we have a reconfiguration message
					switch(reconf_msg->type) {
						case ADD: {
							sched->addWorkers((reconf_msg->w_ids).size(), (reconf_msg->w_ids));
							break;
						}
						case REMOVE:  {
							sched->removeWorkers((reconf_msg->w_ids).size(), (reconf_msg->w_ids));
							break;
						}
						default: {
							cout << "Error: PLQ emitter does not recognize the reconfiguration command!" << endl;
							abort();
						}
					}
					delete reconf_msg;
				}
			}
			else {
				// create the tuple by deserializing the received data
				tuple_t *t = new tuple_t();
				t->create_regular(tuple_buffer, pane_length);
				// process the tuple
				processNewTuple(t);
			}
		}
		while(!stream_complete);
		// send the END message to all the PLQ workers
		sched->broadcast_end_to_w();
		plqTerminated = true;
		return EOS;
	}

	// method to check if the PLQ stage is terminated (or under termination)
	bool isTerminated() { return plqTerminated; }

	// method to acquire the monitored data of the PLQ stage (called by the elastic controller)
	PLQ_Monitored_Data getMonitoredData() {
		return sched->getMonitoredData();
	}
};

/*! 
 *  \class PLQ_Emitter_IOP
 *  
 *  \brief Emitter of the Pane-level Query Stage (IOP version)
 *  
 *  IOP (In-Order-Processing) version of the PLQ emitter functionality.
 *  In this version the tuples are buffered and transmitted in order
 *  to the PLQ workers.
 *  
 *  This class is defined in \ref Pane_Farming/include/plq.hpp
 */
class PLQ_Emitter_IOP: public ff_node_t<tuple_t> {
private:
	int s; // input socket from the Generator
	size_t pane_length; // temporal length of a pane (in ms)
	size_t nw_plq; // number of PLQ worker instances
	int port; // port to receive the connection from the Generator
	bool pidEnabled; // true if adaptive slack mechanism is enabled
	KSlack_Buffer buffer; // reordering buffer based on standard K-slack
	KSlackPID_Buffer bufferPID; // reordering buffer based on adaptive K-slack controlled by a PID
    unsigned long rcv_sample = 0; // number of tuples received in the last sample
    unsigned long dropped_sample = 0; // number of tuples dropped in the last sample
    unsigned long dropped_total = 0; // total number of dropped tuples
    unsigned long rcv_total = 0; // total number of received tuples
    unsigned long out_tuples = 0; // total number of tuples emitted out-of-order
    unsigned long n_extracted_tuples = 0; // total number of tuples extracted from the ordering buffer
    double avg_buffering_time = 0; // average buffering time of the tuples in the ordering buffer
    double last_timestamp = 0; // application timestamp of the last tuple scheduled to the PLQ workers
	ff_loadbalancer * const lb; // load balancer object for the scheduling to PLQ workers
	ff_buffernode * const ch_controller; // fastflow channel from the elastic controller
	bool plqTerminated = false; // if this flag is true the PLQ stage is terminated (or under temination)
#if defined(PB_RR_SCHED)
	PB_RR_Sched *sched;
#elif defined(TB_RR_SCHED)
	TB_RR_Sched *sched;
#elif defined(ADAPTIVE_SCHED)
	Adaptive_Sched *sched;
#elif defined(ADAPTIVE_SCHED_PID)
	Adaptive_Sched_PID *sched;
#endif

	// method to process an input tuple received from the generator
	inline void processNewTuple(tuple_t *t) {
		rcv_sample++;
		rcv_total++;
		// ###################################### START MANAGEMENT OF THE SLACK BUFFER ####################################### //
		// insert the tuple in the buffer
		if(!pidEnabled) {
			buffer.insertTuple(t);
			// extract tuples from the buffer (likely in order)
			t = buffer.extractTuple();
		}
		else {
			bufferPID.insertTuple(t);
			// we adapt the delay of the adaptive K-slack buffer
			double drop_prob =  ((double) dropped_sample)/ ((double) rcv_sample);
			// adapt the slack mechanism
			if(bufferPID.adapt(drop_prob)) {
				// the sampling interval of the PID is finished, we reset the counters for the next one
				dropped_sample = rcv_sample = 0;
			}
			// extract tuples from the buffer (likely in order)
			t = bufferPID.extractTuple();
		}
		while(t != NULL) {
			// update the buffering time
			n_extracted_tuples++;
			avg_buffering_time += (1/ ((double) n_extracted_tuples)) * ((FROM_TICKS_TO_USECS(getticks() - t->arrival_ticks)) - avg_buffering_time);
			// if the tuple is not emitted in order we discard it
			if(t->app_ts < last_timestamp) {
				out_tuples++;
				dropped_sample++;
				dropped_total++;
				delete t;
			}
			// otherwise we schedule the tuple to the PLQ workers
			else {
				// update the timestamp of the last transmitted tuple
				last_timestamp = t->app_ts;
				// ########################################## START SCHEDULING ########################################## //
				// update the statistics for scheduling (all the panes with id < pane_id are likely complete)
				sched->executeStreamProgress(t->app_ts, t->pane_id);
				sched->sched_to_worker(t);
				// ########################################### END SCHEDULING ########################################### //
			}
			if(!pidEnabled) t = buffer.extractTuple();
			else t = bufferPID.extractTuple();
		}
		// ####################################### EMD MANAGEMENT OF THE SLACK BUFFER ######################################## //
	}

	// method to flush the tuples still in the K-slack buffer
	void flushTupleBuffer() {
		// flush the buffer
		tuple_t *next_tuple;
		if(!pidEnabled) {
			buffer.prepareToFlush();
			next_tuple = buffer.extractTuple();
		}
		else {
			bufferPID.prepareToFlush();
			next_tuple = bufferPID.extractTuple();
		}
		while(next_tuple != NULL) {
			// update the buffering time
			n_extracted_tuples++;
			avg_buffering_time += (1/ ((double) n_extracted_tuples)) * ((FROM_TICKS_TO_USECS(getticks() - next_tuple->arrival_ticks)) - avg_buffering_time);
			// if the tuple is not emitted in order we discard it
			if(next_tuple->app_ts < last_timestamp) {
				out_tuples++;
				delete next_tuple;
			}
			// otherwise we schedule the tuple to the PLQ workers
			else {
				// update the timestamp of the last transmitted tuple
				last_timestamp = next_tuple->app_ts;
				// ########################################## START SCHEDULING ########################################## //
				// update the statistics for scheduling (all the panes with id < pane_id are likely complete)
				sched->executeStreamProgress(next_tuple->app_ts, next_tuple->pane_id);
				sched->sched_to_worker(next_tuple);
				// ########################################### END SCHEDULING ########################################### //
			}
			if(!pidEnabled) next_tuple = buffer.extractTuple();
			else next_tuple = bufferPID.extractTuple();
		}
	}

public:
	// constructor
	PLQ_Emitter_IOP(size_t _len, size_t _nw_plq, size_t _port, double _target_drop_prob, ff_loadbalancer * const _lb, ff_buffernode * const _ch_controller)
					:pane_length(_len), nw_plq(_nw_plq), port(_port), pidEnabled(_target_drop_prob>0), bufferPID(_target_drop_prob), lb(_lb), ch_controller(_ch_controller) {}

	// destructor
	~PLQ_Emitter_IOP() {
	    delete sched;
	}

	// svc_init method
	int svc_init() {
		// set the thread mapping onto a SMT context
		ff_mapThreadToCpu(PLQ_EMITTER_CORE_ID);
		// de-activate all the initially non-utilized PLQ workers
		for(int i=nw_plq; i<NUM_WORKER_THREADS; i++) {
			lb->ff_send_out_to(GO_OUT, i);
		}
		// start connection with the Generator
		int *socket = socket_accept(1, port);
		s = *socket;
		// set the socket in the non-blocking mode
		socket_setblocking(s, false);
		MY_PRINT("Connection from Generator: OK\n");
		// entering the sampling barrier
		pthread_barrier_wait(&sampleBarr);
		volatile ticks starting_time = getticks();
		// scheduling strategy instantiation: it must be exectued here and not in the constructor
#if defined(PB_RR_SCHED)
		sched = new PB_RR_Sched(nw_plq, lb);
#elif defined(TB_RR_SCHED)
		sched = new TB_RR_Sched(nw_plq, lb);
#elif defined(ADAPTIVE_SCHED)
		sched = new Adaptive_Sched(nw_plq, lb);
#elif defined(ADAPTIVE_SCHED_PID)
		sched = new Adaptive_Sched_PID(nw_plq, lb, starting_time, desired_rho); // desired_rho is a global variable
#endif
		return 0;
	}

	// svc_end method
	void svc_end() {
		// close connection with the Generator
		socket_close(s);
		// entering the printing barrier
		pthread_barrier_wait(&printBarr);
		// check whether there are some pending tuples in the k-slack buffer
		if(buffer.getSize() != 0) MY_PRINT("PLQ emitter (IOP) has some pending tuples in buffer!\n");
		MY_PRINT("********************************PLQ statistics********************************\n" <<\
			      "Out-of-Order tuples: " << out_tuples << "/" << rcv_total << " tuples\n" <<\
			      "Average buffering time: " << avg_buffering_time/1000 << " ms\n" <<\
			      "Average splitting factor: " << sched->getPLQSplitFactor() << "\n" <<\
			      "******************************************************************************\n");
#if defined(PLQ_ONLY)
		// entering the precedence barrier 1
		pthread_barrier_wait(&precBarr1);
		// entering the precedence barrier 2
		pthread_barrier_wait(&precBarr2);
#else
		// entering the precedence barrier 1
		pthread_barrier_wait(&precBarr1);
		// entering the precedence barrier 2
		pthread_barrier_wait(&precBarr2);
		// entering the precedence barrier 3
		pthread_barrier_wait(&precBarr3);
#endif
	}

	// svc method
	tuple_t *svc(tuple_t *t) {
		char tuple_buffer[tuple_t::getSize()];
		bool stream_complete = false;
		// loop until the end of the stream
		do {
			int received = socket_receive(s, tuple_buffer, tuple_t::getSize());
			if(received == 0) stream_complete = true;
			else if(received == -1) {
				// check the presence of a message from the manager
				Reconf_t *reconf_msg = nullptr;
				ch_controller->gather_task(reconf_msg, 1);
				if(reconf_msg != nullptr) {
					// we have a reconfiguration message
					switch(reconf_msg->type) {
						case ADD: {
							sched->addWorkers((reconf_msg->w_ids).size(), (reconf_msg->w_ids));
							break;
						}
						case REMOVE:  {
							sched->removeWorkers((reconf_msg->w_ids).size(), (reconf_msg->w_ids));
							break;
						}
						default: {
							cout << "Error: controller thread does not recognize the reconfiguration command" << endl;
							abort();
						}
					}
					delete reconf_msg;
				}
			}
			else {
				// create the tuple by deserializing the received data
				tuple_t *t = new tuple_t();
				t->create_regular(tuple_buffer, pane_length);
				// process the tuple
				processNewTuple(t);
			}
		}
		while(!stream_complete);
		// flush all the remaining tuples in the k-slack buffer
		flushTupleBuffer();
		// send the END message to all the PLQ workers
		sched->broadcast_end_to_w();
		plqTerminated = true;
		return EOS;
	}

	// method to check if the PLQ stage is terminated (or under termination)
	bool isTerminated() { return plqTerminated; }

	// method to acquire the monitored data of the PLQ stage (called by the elastic controller)
	PLQ_Monitored_Data getMonitoredData() {
		return sched->getMonitoredData();
	}
};

/*! 
 *  \class PLQ_Worker
 *  
 *  \brief Worker of the Pane-level Query Stage
 *  
 *  Worker functionality of the PLQ stage of the Pane Farming pattern. It is
 *  responsible to receive the tuple messages from the emitter, and to add them
 *  to results set of the corresponding pane. Panes are computed incrementally.
 *  Punctuations received by the emitter allow the PLQ worker to close a subset
 *  of its panes by transmitting them to the next stage (WLQ).
 *  
 *  This class is defined in \ref Pane_Farming/include/plq.hpp
 */
template<typename Rset_t>
class PLQ_Worker: public ff_node_t<tuple_t, Rset_t> {
private:
	size_t wp; // window length in terms of number of panes
	size_t sp; // window slide in terms of number of panes
	unsigned long pane_length; // temporal length of a pane (in ms)
	deque<Rset_t *> paneSet; // deque of the results sets of the open panes
	Rset_t fakePane; // empty results set of a fake pane used by the search algorithm
	size_t cpuid; // identifier of the SMT context on which this PLQ worker is executed
	bool flagCPUInitialized = false; // if this flag is false, we need to initialize the SMT context of this PLQ worker (just the first time)
	// if LOG mode is enabled we need the following variables for statistics
#if defined(LOG)
	size_t rcv_tuples = 0; // no. of received regular tuples
	double avg_deque_size = 0; // average size of the deque
	size_t rcv_punctuations = 0; // no. of punctuations received
	size_t rcv_punc_closing = 0; // no. of punctuations that close at least one pane instance
	double avg_pane_closed = 0; // average number of pane instances closed per received closing punctuation
	double avg_proc_time = 0; // average processing time per tuple (in usec)
#endif

	// method to compute the number of windows containing the pane with id pane_id
	inline size_t countWindows(size_t pane_id) {
		// adjust the identifier (starting from 1 is better)
		double idx = pane_id + 1;
		size_t first;
		if(idx < wp) first = 1;
		else first = ceil((idx - wp) / sp) + 1;
		size_t last = ceil(idx / sp);
		return (first-last+1);
	}

public:
	// constructor
	PLQ_Worker(size_t _wp, size_t _sp, unsigned long _len, size_t _cpuid): wp(_wp), sp(_sp), pane_length(_len), cpuid(_cpuid) {}

	// destructor
	~PLQ_Worker() {}

	// svc_init method
	int svc_init() {
		// set the PLQ worker thread on the given SMT context if needed
		if(!flagCPUInitialized) {
			ff_mapThreadToCpu(cpuid);
			flagCPUInitialized = true;
		}
		return 0;
	}

	// svc_end method
	void svc_end() {}

	// method to properly manage the arrival of the EOS
	void eosnotify(ssize_t id) {
		// check whether there are some pending panes in deque
		if(paneSet.size() != 0) MY_PRINT("PLQ worker has some pending panes in deque!\n");
		// if LOG mode is enabled we write on the log file
#if defined(LOG)
		ostringstream stream;
 		stream << "********************************PLQ worker " << this->get_my_id() << "********************************\n";
 		stream << "Received tuples: " << rcv_tuples << "\n";
 		stream << "Received punctuations: " << rcv_punctuations << "\n";
 		stream << "Average deque size: " << avg_deque_size << "\n";
 		stream << "Average pane instances closed per punct.: " << avg_pane_closed << "\n";
 		stream << "Average processing time per tuple (us): " << avg_proc_time << "\n";
    	LOG_PLQ_WRITE(stream);
#endif
	}

	// svc method
	Rset_t *svc(tuple_t *t) {
		// the input tuple is a PUNCT
		if(t->type == PUNCT) {
			/* 
			 * We do the following actions:
			 * 1- find the results sets of all the panes to be closed;
			 * 2- the results sets of the closed panes are transmitted to the next stage.
			 */
			fakePane.setId(t->pane_id);
			// atomically decrement the tuple's reference counter
			size_t old_cnt = (t->refCounter).fetch_sub(1);
			// if I am the last, I can destroy the tuple
			if(old_cnt == 1) delete t;
			// if LOG mode is enabled we update the statistics
#if defined(LOG)
			rcv_punctuations++;
			avg_deque_size = avg_deque_size + (1/((double) rcv_punctuations)) * (paneSet.size() - avg_deque_size);
#endif
			auto it = std::lower_bound(paneSet.begin(), paneSet.end(), &fakePane,
									   [](Rset_t *l, Rset_t *r)
									   { return l->getId() < r->getId(); });
			size_t n_closed = 0; // no. of closed panes
			// the results sets of the closed panes are transmitted to the next stage
			for(auto p=paneSet.begin(); p<it; p++) {
				n_closed++;
				Rset_t *result = (*p);
				// set the closing time of the results set
				result->setClosingTime(getticks());
				while(!ff_node_t<tuple_t, Rset_t>::ff_send_out(result));
			}
#if defined(LOG)
			// check whether the punctuation has closed some panes
			if(it > paneSet.begin()) {
				rcv_punc_closing++;
				avg_pane_closed += (1/(double) rcv_punc_closing) * (n_closed - avg_pane_closed);
			}
#endif
			// remove the results sets of the closed panes from the deque
			paneSet.erase(paneSet.begin(), it);
			return ff_node_t<tuple_t, Rset_t>::GO_ON;
		}
		// the input is a END message
		else if(t->type == END) {
			/* 
			 * We do the following actions:
			 * 1- the results sets that are in deque are transmitted to the next stage;
			 * 2- we empty the deque.
			 */
			// atomically decrement the tuple's reference counter
			size_t old_cnt = (t->refCounter).fetch_sub(1);
			// if I am the last, I can destroy the tuple
			if(old_cnt == 1) delete t;
			// all the results sets in deque are transmitted to the next stage
			for(auto p=paneSet.begin(); p < paneSet.end(); p++) {
				Rset_t *result = (*p);
				// set the closing time of the results set
				result->setClosingTime(getticks());
				while(!ff_node_t<tuple_t, Rset_t>::ff_send_out(result));
			}
			// empty the deque
			paneSet.clear();
			return ff_node_t<tuple_t, Rset_t>::GO_ON;
		}
		// the input is a NEW_INST message
		else if(t->type == NEW_INST) {
			/* 
			 * We do the following actions:
			 * 1- we find the results set of the corresponding pane (it must exist!);
			 * 2- change the counter of instances of that results set.
			 */
			fakePane.setId(t->pane_id);
			auto it = std::lower_bound(paneSet.begin(), paneSet.end(), &fakePane,
									   [](Rset_t *l, Rset_t *r)
									   { return l->getId() < r->getId(); });
			// if the results set of the pane does not exist abort
			if((it == paneSet.end()) || ((*it)->getId() != t->pane_id)) abort();
			else {
				(*it)->setNoInstances(t->no_instances);
				// atomically decrement the tuple's reference counter
				size_t old_cnt = (t->refCounter).fetch_sub(1);
				// if I am the last, I can destroy the tuple
				if(old_cnt == 1) delete t;
				return ff_node_t<tuple_t, Rset_t>::GO_ON;
			}
		}
		// the input is a FLUSH message
		else if(t->type == FLUSH) {
			/* 
			 * We do the following actions:
			 * 1- all the results sets in deque are extracted;
			 * 2- the results sets are transmitted to the WLQ.
			 */
			// atomically decrement the tuple's reference counter
			size_t old_cnt = (t->refCounter).fetch_sub(1);
			// if I am the last, I can destroy the tuple
			if(old_cnt == 1) delete t;
			// all the results sets in deque are transmitted to the next stage
			for(auto p=paneSet.begin(); p < paneSet.end(); p++) {
				Rset_t *result = (*p);
				result->setNoInstances(0); // 0 means that the no. of occurrences is unspecified!
				// set the closing time of the results set
				result->setClosingTime(getticks());
				while(!ff_node_t<tuple_t, Rset_t>::ff_send_out(result));
			}
			// empty the deque
			paneSet.clear();
			return ff_node_t<tuple_t, Rset_t>::GO_ON;
		}
		// the input is a LULL message
		else if(t->type == LULL) {
			/* 
			 * We do the following actions:
			 * 1- a new results set of the pane pane_id is created;
			 * 2- the empty results set is immediately produced to the WLQ.
			 */
			// compute the number of windows to which the results set belongs
			size_t cntWin = countWindows(t->pane_id);
			Rset_t *pane = new Rset_t(cntWin, t->pane_id, t->no_instances);
			// set all the times (starting, ending and closing) of the results set
			pane->setStartingTime(getticks());
			pane->setEndingTime(getticks());
			pane->setClosingTime(getticks());
			while(!ff_node_t<tuple_t, Rset_t>::ff_send_out(pane));
			return ff_node_t<tuple_t, Rset_t>::GO_ON;
		}
		// the input is a REGULAR tuple or an EMPTYPANE message
		else {
			/* 
			 * We do the following actions:
			 * 1- we find whether a results set of the pane exists otherwise we create it;
			 * 2- we add the tuple to the results set (if t is REGULAR);
			 * 3- we update the results set (if t is REGULAR).
			 */
			// search the results set of the pane in the paneSet
			fakePane.setId(t->pane_id);
			auto it = std::lower_bound(paneSet.begin(), paneSet.end(), &fakePane,
									   [](Rset_t *l, Rset_t *r)
									   { return l->getId() < r->getId(); });
			Rset_t *pane;
			// if the results set is not present and it has the largest id
			if(it == paneSet.end()) {
				// compute the number of windows to which this results set belongs
				size_t cntWin = countWindows(t->pane_id);
				pane = new Rset_t(cntWin, t->pane_id, t->no_instances);
				paneSet.push_back(pane);
			}
			// if the results set is not present and it goes in the middle of the deque
			else if((*it)->getId() != t->pane_id) {
				// compute the number of windows to which this results set belongs
				size_t cntWin = countWindows(t->pane_id);
				pane = new Rset_t(cntWin, t->pane_id, t->no_instances);
				paneSet.insert(it, pane);
			}
			// if the results set already exists
			else {
				pane = *it;
			}
#if defined(LOG)
			rcv_tuples++;
			volatile ticks start_time = getticks();
#endif
			// add the tuple to the results set and compute it t is REGULAR
			if(t->type == REGULAR) pane->addComputeTuple(*t);
			else {
				// set all the times (starting and ending) of the results set
				pane->setStartingTime(getticks());
				pane->setEndingTime(getticks());
			}
#if defined(LOG)
			volatile ticks end_time = getticks();
			double elapsed_time = FROM_TICKS_TO_USECS(end_time - start_time);
			avg_proc_time += (1/(double) rcv_tuples) * (elapsed_time - avg_proc_time);
#endif
			// delete the tuple
			delete t;
			return ff_node_t<tuple_t, Rset_t>::GO_ON;
		}
	}
};

/*! 
 *  \class PLQ_Worker_IOP
 *  
 *  \brief Worker of the Pane-level Query Stage (IOP version)
 *  
 *  IOP (In-Order-Processing) version of the PLQ worker functionality.
 *  In this version the tuples are received in-order from the PLQ emitter.
 *  
 *  This class is defined in \ref Pane_Farming/include/plq.hpp
 */
template<typename Rset_t>
class PLQ_Worker_IOP: public ff_node_t<tuple_t, Rset_t> {
private:
	size_t wp; // window length in terms of number of panes
	size_t sp; // window slide in terms of number of panes
	size_t pane_length; // temporal length of a pane (in ms)
	deque<Rset_t *> paneSet; // deque of the results set of the open panes
	Rset_t fakePane; // empty results set of a fake pane used by the search algorithm
	int cpuid; // identifier of the SMT context on which this PLQ worker is executed
	bool flagCPUInitialized = false; // if this flag is false, we need to initialize the SMT context of this PLQ worker (just one time)
	// if LOG mode is enabled we need the following variables for statistics
#if defined(LOG)
	size_t rcv_tuples = 0; // no. of received regular tuples
	double avg_proc_time = 0; // average processing time per tuple (in usec)
#endif

	// method to compute the number of windows containing the pane with id pane_id
	inline size_t countWindows(size_t pane_id) {
		// adjust the identifier (starting from 1 is better)
		double idx = pane_id + 1;
		size_t first;
		if(idx < wp) first = 1;
		else first = ceil((idx - wp) / sp) + 1;
		size_t last = ceil(idx / sp);
		return (first-last+1);
	}

public:
	// constructor
	PLQ_Worker_IOP(size_t _wp, size_t _sp, size_t _len, int _cpuid): wp(_wp), sp(_sp), pane_length(_len), cpuid(_cpuid) {}

	// destructor
	~PLQ_Worker_IOP() {}

	// svc_init method
	int svc_init() {
		// set the PLQ worker thread on the given SMT context if needed
		if(!flagCPUInitialized) {
			ff_mapThreadToCpu(cpuid);
			flagCPUInitialized = true;
		}
		return 0;
	}

	// svc_end method
	void svc_end() {}

	// method to properly manage the arrival of the EOS
	void eosnotify(ssize_t id) {
		// check whether there are some pending panes in deque
		if(paneSet.size() != 0) MY_PRINT("PLQ worker has some pending panes in deque!\n");
		// if LOG mode is enabled we write on the log file
#if defined(LOG)
		ostringstream stream;
 		stream << "********************************PLQ worker (IOP) " << this->get_my_id() << "********************************\n";
 		stream << "Received tuples: " << rcv_tuples << "\n";
 		stream << "Average processing time per tuple (us): " << avg_proc_time << "\n";
    	LOG_PLQ_WRITE(stream);
#endif
	}

	// svc method
	Rset_t *svc(tuple_t *t) {
		// if the input is a END message
		if(t->type == END) {
			/* 
			 * We do the following actions:
			 * 1- the results sets that are in deque are transmitted to the next stage;
			 * 2- we empty the deque.
			 */
			// atomically decrement the tuple's reference counter
			size_t old_cnt = (t->refCounter).fetch_sub(1);
			// if I am the last, I can destroy the tuple
			if(old_cnt == 1) delete t;
			// all the results sets in deque are transmitted to the next stage
			for(auto p=paneSet.begin(); p < paneSet.end(); p++) {
				Rset_t *result = (*p);
				while(!ff_node_t<tuple_t, Rset_t>::ff_send_out(result));
			}
			// empty the deque
			paneSet.clear();
			return ff_node_t<tuple_t, Rset_t>::GO_ON;
		}
		// the input is a NEW_INST message
		else if(t->type == NEW_INST) {
			/* 
			 * We do the following actions:
			 * 1- we find the results set of the corresponding pane (it must exist!);
			 * 2- change the counter of instances of that results set.
			 */
			fakePane.setId(t->pane_id);
			auto it = std::lower_bound(paneSet.begin(), paneSet.end(), &fakePane,
									   [](Rset_t *l, Rset_t *r)
									   { return l->getId() < r->getId(); });
			// if the results set of the pane does not exist abort
			if((it == paneSet.end()) || ((*it)->getId() != t->pane_id)) abort();
			else {
				(*it)->setNoInstances(t->no_instances);
				// atomically decrement the tuple's reference counter
				size_t old_cnt = (t->refCounter).fetch_sub(1);
				// if I am the last, I can destroy the tuple
				if(old_cnt == 1) delete t;
				return ff_node_t<tuple_t, Rset_t>::GO_ON;
			}
		}
		// the input is a FLUSH message
		else if(t->type == FLUSH) {
			/* 
			 * We do the following actions:
			 * 1- all the results sets in deque are extracted;
			 * 2- the results sets are transmitted to the WLQ.
			 */
			// atomically decrement the tuple's reference counter
			size_t old_cnt = (t->refCounter).fetch_sub(1);
			// if I am the last, I can destroy the tuple
			if(old_cnt == 1) delete t;
			// all the results sets in deque are transmitted to the next stage
			for(auto p=paneSet.begin(); p < paneSet.end(); p++) {
				Rset_t *result = (*p);
				/* 
				 * IOP: all the results sets of the panes with identifier smaller than
				 * the one in the FLUSH message are closed and they can be emitted
				 * with the current instance counter.
				 */
				if(result->getId() >= t->pane_id) result->setNoInstances(0); // 0 means that the no. of occurrences is unspecified!
				while(!ff_node_t<tuple_t, Rset_t>::ff_send_out(result));
			}
			// empty the deque
			paneSet.clear();
			return ff_node_t<tuple_t, Rset_t>::GO_ON;
		}
		// the input is a LULL message
		else if(t->type == LULL) {
			/* 
			 * We do the following actions:
			 * 1- a new results set of the pane pane_id is created;
			 * 2- the empty results set is immediately produced to the WLQ.
			 */
			// compute the number of windows to which the results set belongs
			size_t cntWin = countWindows(t->pane_id);
			Rset_t *pane = new Rset_t(cntWin, t->pane_id, t->no_instances);
			// set all the times (starting, ending and closing) of the results set
			pane->setStartingTime(getticks());
			pane->setEndingTime(getticks());
			pane->setClosingTime(getticks());
			while(!ff_node_t<tuple_t, Rset_t>::ff_send_out(pane));
			return ff_node_t<tuple_t, Rset_t>::GO_ON;
		}
		// the input is a REGULAR tuple or an EMPTYPANE message
		else {
			/* 
			 * We do the following actions:
			 * 1- we find whether the results set of the pane exists otherwise we create it;
			 * 2- all the previous results sets can be closed;
			 * 3- we add the tuple t to the results set of the pane (if t is REGULAR);
			 * 4- we update the results set of the pane (if t is REGULAR).
			 */
			// search the results set of the pane in the paneSet
			fakePane.setId(t->pane_id);
			auto it = std::lower_bound(paneSet.begin(), paneSet.end(), &fakePane,
									   [](Rset_t *l, Rset_t *r)
									   { return l->getId() < r->getId(); });
			// all the previous results sets can be closed (IOP)
			for(auto p=paneSet.begin(); p < it; p++) {
				Rset_t *result = (*p);
				while(!ff_node_t<tuple_t, Rset_t>::ff_send_out(result));
			}
			Rset_t *pane;
			// if the results set is not present (it must be added at the end - IOP)
			if(it == paneSet.end()) {
				// compute the number of windows to which this results set belongs
				size_t cntWin = countWindows(t->pane_id);
				pane = new Rset_t(cntWin, t->pane_id, t->no_instances);
				// remove the results sets of the closed panes from the deque
				paneSet.erase(paneSet.begin(), it);
				paneSet.push_back(pane);
			}
			// if the results set already exists
			else {
				pane = *it;
			}
#if defined(LOG)
			rcv_tuples++;
			volatile ticks start_time = getticks();
#endif
			// add the tuple to the results set and compute it if it is REGULAR
			if(t->type == REGULAR) pane->addComputeTuple(*t);
			else {
				// set all the times (starting and ending) of the results set
				pane->setStartingTime(getticks());
				pane->setEndingTime(getticks());
			}
			// set the closing time of the results set
			pane->setClosingTime(getticks());
#if defined(LOG)
			volatile ticks end_time = getticks();
			double elapsed_time = FROM_TICKS_TO_USECS(end_time - start_time);
			avg_proc_time += (1/(double) rcv_tuples) * (elapsed_time - avg_proc_time);
#endif
			// delete the regular tuple
			delete t;
			return ff_node_t<tuple_t, Rset_t>::GO_ON;
		}
	}
};

#endif
